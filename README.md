# component

### 公共组件库，包括缓存组件，分库分表组件，SFTP工具类。与Mybatis-plus兼容。


#### 缓存组件
##### 类似Spring cache，但是spring cache无法保证缓存一致性的问题，只是简单的缓存和删除key。本缓存组件基于Spring AOP实现，并且支持过期时间和主动刷新缓存（异步），防止缓存雪崩，并且数据库如果不存在该值，返回一个空值，防止缓存穿透。实体对象数据可以保证缓存一致性，主要通过分布式锁来实现。

@CacheAble 主键可以缓存指定方法中的返回对象，可以是全局返回结果，也可以是局部返回结果。

@CacheAbleEntity 注解可以缓存指定方法中的返回实体对象，可以缓存各种查询条件的索引key，每条索引key对应同一个主键key，主键key存的就是该实体对象。这样可以节省内存，并且在实体对象更新的时候每个索引key都可以后去到最新的值。实体对象在新增、更新或删除数据库的某条记录时，先删除对应的缓存，再进行更新操作。具体流程图如下：

![缓存一致性流程](https://github.com/Evai/images/blob/master/introduce/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png)

#### 分库分表组件
##### 该组件比较简单，基本原理是根据分布式主键拆分表，将数据划分为多个连续的部分，按数据的ID分布到不同表上。例如 User 表的 ID 范围为 1 ~ N，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，2001 ~ 3000，...。当表大于一定的记录数时，自动创建下一张表并插入记录。理论上可以支持表的无限水平扩容。分表的后缀名为该表的第一个主键值。假设查询条件是根据主键id，那么一开始会先将所有分表的表名存到一个本地软引用缓存里，然后路由方法会将id匹配到其中的一个表，再从该表里查询。如果是分页查询或其它条件查询，会并行的从所有表中查询符合条件的记录，然后再筛选出来。支持单表的增删改查，基本上单表查询方法已经包含了大部分业务场景。如果想连表查询或自定义sql查询，也有对应的方法，不过sql语句和查询后的结果封装写的时候要谨慎考虑。

如何使用请参考项目中的[demo](https://github.com/Evai/component/tree/master/src/main/java/com/evai/component/demo)。


